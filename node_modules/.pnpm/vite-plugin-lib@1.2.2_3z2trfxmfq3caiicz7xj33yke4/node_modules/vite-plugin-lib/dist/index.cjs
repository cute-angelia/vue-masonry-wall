'use strict';

const node_fs = require('node:fs');
const promises = require('node:fs/promises');
const node_module = require('node:module');
const path = require('node:path');
const c = require('picocolors');
const ts = require('typescript');
const dts = require('vite-plugin-dts');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const path__default = /*#__PURE__*/_interopDefaultCompat(path);
const c__default = /*#__PURE__*/_interopDefaultCompat(c);
const ts__default = /*#__PURE__*/_interopDefaultCompat(ts);
const dts__default = /*#__PURE__*/_interopDefaultCompat(dts);
const dts__namespace = /*#__PURE__*/_interopNamespaceCompat(dts);

function log(text) {
  console.log(`${c__default.cyan("[vite:lib]")} ${text}`);
}
function logWarn(text) {
  console.warn(`${c__default.yellow("[vite:lib]")} ${text}`);
}
function logError(text) {
  console.error(`${c__default.red("[vite:lib]")} ${text}`);
}
function tsconfigPaths({ verbose } = {}) {
  return {
    name: "vite-plugin-lib:alias",
    enforce: "pre",
    config: async (config) => {
      const tsconfigPath = path__default.resolve(config.root ?? ".", "tsconfig.json");
      const { baseUrl, paths } = await readConfig(tsconfigPath);
      if (!baseUrl || !paths) {
        log("No paths found in tsconfig.json.");
        return config;
      }
      const pathToAlias = pathToAliasFactory(tsconfigPath, baseUrl, verbose);
      const aliasOptions = Object.entries(paths).map(pathToAlias).filter(Boolean);
      if (aliasOptions.length > 0) {
        logInjectedAliases(aliasOptions, config, verbose);
      }
      const existingAlias = transformExistingAlias(config.resolve?.alias);
      return {
        ...config,
        resolve: {
          ...config.resolve,
          alias: [...existingAlias, ...aliasOptions]
        }
      };
    }
  };
}
function buildConfig({
  entry,
  formats,
  name,
  externalPackages
}) {
  if (!externalPackages) {
    log("Externalized all packages.");
  }
  return {
    name: "vite-plugin-lib:build",
    enforce: "pre",
    config: async (config) => {
      return {
        ...config,
        build: {
          ...config.build,
          lib: {
            ...config.build?.lib,
            entry: path__default.resolve(config.root ?? ".", entry),
            formats,
            name,
            fileName: (format) => formatToFileName(entry, format)
          },
          rollupOptions: {
            external: externalPackages ?? [/node_modules/, ...node_module.builtinModules]
          }
        }
      };
    }
  };
}
function logInjectedAliases(aliasOptions, config, verbose) {
  log(`Injected ${c__default.green(aliasOptions.length)} aliases.`);
  if (!verbose) {
    return;
  }
  const base = `${path__default.resolve(config.root ?? ".")}/`;
  aliasOptions.map(
    ({ find, replacement }) => `${c__default.gray(">")} ${c__default.green(find.toString())} ${c__default.gray(
      c__default.bold("->")
    )} ${c__default.green(replacement.replace(base, ""))}`
  ).forEach(log);
}
function pathToAliasFactory(tsconfigPath, baseUrl, verbose) {
  return ([alias, replacements]) => {
    if (replacements.length === 0) {
      if (verbose) {
        logWarn(`No replacements for alias ${c__default.green(alias)}.`);
      }
      return void 0;
    }
    if (verbose && replacements.length > 1) {
      logWarn(`Found more than one replacement for alias ${c__default.green(alias)}.`);
      logWarn("Using the first existing replacement.");
    }
    const find = alias.replace("/*", "");
    const replacement = getFirstExistingReplacement(
      tsconfigPath,
      baseUrl,
      replacements,
      find
    );
    if (!replacement) {
      if (verbose) {
        logWarn(`No replacement found for alias ${c__default.green(alias)}.`);
      }
      return void 0;
    }
    return {
      find,
      replacement
    };
  };
}
function getFirstExistingReplacement(tsconfigPath, baseUrl, replacements, find, verbose) {
  for (const replacement of replacements) {
    const resolvedReplacement = path__default.resolve(
      tsconfigPath,
      baseUrl,
      replacement.replace("/*", "") ?? find
    );
    if (node_fs.existsSync(resolvedReplacement)) {
      return resolvedReplacement;
    } else if (verbose) {
      logWarn(`Path ${c__default.green(replacement)} does not exist.`);
    }
  }
  return void 0;
}
function formatToFileName(entry, format) {
  const entryFileName = entry.substring(
    entry.lastIndexOf("/") + 1,
    entry.lastIndexOf(".")
  );
  if (format === "es") {
    return `${entryFileName}.mjs`;
  }
  if (format === "cjs") {
    return `${entryFileName}.cjs`;
  }
  return `${entryFileName}.${format}.js`;
}
function library(options) {
  return [
    tsconfigPaths(),
    buildConfig(options),
    dts__default({
      cleanVueFileName: true,
      copyDtsFiles: true,
      include: `${path__default.resolve(options.entry, "..")}**`,
      outputDir: "dist/types",
      staticImport: true
    })
  ];
}
function transformExistingAlias(alias) {
  if (!alias) {
    return [];
  }
  if (Array.isArray(alias)) {
    return alias;
  }
  return Object.entries(alias).map(([find, replacement]) => ({
    find,
    replacement
  }));
}
async function readConfig(configPath) {
  try {
    const configFileText = await promises.readFile(configPath, { encoding: "utf-8" });
    const { config } = ts__default.parseConfigFileTextToJson(configPath, configFileText);
    if (!("baseUrl" in config?.compilerOptions)) {
      throw new Error("No baseUrl provided in tsconfig.json.");
    }
    const { options } = ts__default.parseJsonConfigFileContent(
      config,
      // eslint-disable-next-line import/no-named-as-default-member
      ts__default.sys,
      path__default.dirname(configPath)
    );
    return options;
  } catch (error) {
    const message = "message" in error ? error.message : error;
    logError(`Could not read tsconfig.json: ${message}`);
    throw error;
  }
}

exports.dts = dts__namespace;
exports.library = library;
exports.tsconfigPaths = tsconfigPaths;
